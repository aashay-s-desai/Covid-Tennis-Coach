# -*- coding: utf-8 -*-
"""Tennis Shot Logistic Regression

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1enXVq_m2Cm8pYgehMSUa3IE_GoXPneM-
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
# %matplotlib inline

#Training Data Set and Plotting
df = pd.read_csv('/New Summed Data.csv', usecols = [0,1,2,3,4,5,6])
df.columns = ['aX','aY','aZ','gX','gY','gZ','g_b']
df

'''
#Making all degrees between 0 and 360 (gX,gY,gZ)
dfArr = df.values.tolist()
for i in range(0,len(dfArr)):
    for j in range(3,len(dfArr[i])-1):
        print("dfArr[i][j] = ", dfArr[i][j])
        x = 1
        while(abs(dfArr[i][j])>=(360*x)): # making it >= would make it so all values are less that 360 (0<=x<360)
            x+=1
        if (dfArr[i][j]<0):
          dfArr[i][j]+=(360*(x-1))
        else:
          dfArr[i][j]-=(360*(x-1)) #you do x-1 because x is the value at which the while loop fails
        print("dfArr[i][j]after subtraction = ", dfArr[i][j])
print(dfArr)
'''

'''
df = pd.DataFrame(dfArr)
df.columns = ['aX','aY','aZ','gX','gY','gZ','g_b']
df
'''

#plt.scatter(df.gY,df.g_b,marker='*',c='green')





#Standardization
from sklearn.preprocessing import StandardScaler

scaling = StandardScaler()

scaledArr = scaling.fit_transform(df[['aX','aY','aZ','gX','gY','gZ']])

#numpy array
scaledArr

g_bList = df.g_b.tolist()
g_bList

#converting numpy array to regular list
scaledList = scaledArr.tolist()
scaledList

#adding g_b (binary) to the scaledList
for i in range(0,len(scaledList)):
  scaledList[i].append(g_bList[i])
print(scaledList)

#summing scaledArr
for i in range (0, len(scaledList)):
  for j in range(len(scaledList[i])-2,0,-1):
    scaledList[i][j-1]+=scaledList[i][j]
    scaledList[i].pop(j)
    #print(scaledList);
print(scaledList)

#converting list to pandas dataframe
dfScaled = pd.DataFrame(scaledList)
dfScaled.columns = ['summedData', 'g_b']
dfScaled

plt.scatter(dfScaled.summedData,dfScaled.g_b,marker='+',c='blue')

x = dfScaled.summedData.to_numpy()
z = 1/(1 + np.exp(-x))

plt.plot(x, z)
plt.xlabel("Summed Accelerometer and Gyroscope Data")
plt.ylabel("Model Confidence in Shot")

plt.show()

x = np.linspace(-10, 10, 100)
x

z = 1/(1 + np.exp(-x))

plt.plot(x, z)
plt.xlabel("x")
plt.ylabel("Sigmoid(X)")

plt.show()





#Training and Testing Data
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(dfScaled[['summedData']],dfScaled.g_b,test_size= 0.1)

x_test
#x_train
#y_test
#y_train

from sklearn.linear_model import LogisticRegression

model = LogisticRegression()

model.fit(x_train,y_train)





#Using model test data
model.predict(x_test)

model.predict_proba(x_test)

model.score(x_test,y_test)





#Using my own testing data set
df2 = pd.read_csv('/Test 2 Data 7-28.csv')
df2.columns = ['aX','aY','aZ','gX','gY','gZ','g_b']
df2





#Scaling Test Data
test_scaledArr = scaling.fit_transform(df2[['aX','aY','aZ','gX','gY','gZ']])
test_scaledArr

#PLAYING AROUND WITH DATAFRAME AND IT METHODS (TEST LATER)
#df2.values #.values converts dataframe to numpy array
#df2.g_b #.g_b (.nameOfColumn) converts dataframe to
#df2['g_b'] #converts
#df2[['g_b']] #dataframe of a single column
#df2.g_b.values #.g_b.values converts to numpy array
#df2[['g_b']].values #converts dataframe of column to numpy array
#Search up Numpy Array vs. List

test_g_bList = df2.g_b.tolist()
test_g_bList

test_scaledList = test_scaledArr.tolist()
test_scaledList

for i in range(0,len(test_scaledList)):
  test_scaledList[i].append(test_g_bList[i])
test_scaledList

for i in range(0,len(test_scaledList)):
  for j in range(len(test_scaledList[i])-2,0,-1):
    test_scaledList[i][j-1]+=test_scaledList[i][j]
    test_scaledList[i].pop(j)
    #print(test_scaledList);
print(test_scaledList)

df2Scaled = pd.DataFrame(test_scaledList)
df2Scaled.columns = ['summedData', 'g_b']
df2Scaled

plt.scatter(df2Scaled.summedData,df2Scaled.g_b,marker='+',c='blue')





#My Data Prediction
model.predict(df2Scaled[['summedData']])

model.predict_proba(df2Scaled[['summedData']])

#df2Scaled_y = model.predict(df2Scaled[['summedData']])
df2Scaled_y = df2Scaled.g_b
df2Scaled_y

#parameters: x_test, y_test; model calculates y_predict for you based on x_test so no need to input it
model.score(df2Scaled[['summedData']],df2Scaled_y)





#Making all degrees between 0 and 360 (gX,gY,gZ) (do this after creating model because makes model less accurate for some reason)
df2Arr = df2.values.tolist()
for i in range(0,len(df2Arr)):
    for j in range(3,len(df2Arr[i])-1):
        print("df2Arr[i][j] = ", df2Arr[i][j])
        x = 1
        while(abs(df2Arr[i][j])>=(360*x)): # making it >= would make it so all values are less that 360 (0<=x<360)
            x+=1
        if (df2Arr[i][j]<0):
          df2Arr[i][j]+=(360*(x-1))
        else:
          df2Arr[i][j]-=(360*(x-1)) #you do x-1 because x is the value at which the while loop fails
        print("df2Arr[i][j]after subtraction = ", df2Arr[i][j])
print(df2Arr)

df2 = pd.DataFrame(df2Arr)
df2.columns = ['aX','aY','aZ','gX','gY','gZ','g_b']
df2





#The degrees of the shots the user got wrong (that the algorithm predicted was wrong)
predictedValsList = model.predict(df2Scaled[['summedData']]).tolist()
userWrongIndexList = []
for i in range(0,len(predictedValsList)):
  if(predictedValsList[i]==0):
    userWrongIndexList.append(i)
userWrongIndexList

gDimensionsList = []
for i in range (0,len(userWrongIndexList)):
  gDimensionsList.append([])
  for j in range(0,3):
    gDimensionsList[i].append(df2Arr[userWrongIndexList[i]][3+j])
gDimensionsList

#Converting Dimensions List to Pandas DataFrame
gDimensionsDF = pd.DataFrame(gDimensionsList)
gDimensionsDF.columns = ['gX','gY','gZ']
#gDimensionsDF = gDimensionsDF.rename(index = {0:indexArr[0], 1:indexArr[1], 2:indexArr[2]}) figure out how to do non-manually
print("indexes with issues (user) in order: ", userWrongIndexList)
print("Their respective dimensional angles from the gyroscope are recorded below, in index numerical order: ")
gDimensionsDF









#The degrees of the shots the algorithm got wrong
predictedValsList = model.predict(df2Scaled[['summedData']]).tolist()

knownValsList = df2Scaled_y.tolist()

#List of the indexes the algorithm got wrong
indexArr = []
for i in range(0,len(predictedValsList)):
  if (predictedValsList[i]!=knownValsList[i]):
    indexArr.append(i)
indexArr

gDimensionsList = []
for i in range (0,len(indexArr)):
  gDimensionsList.append([])
  for j in range(0,3):
    gDimensionsList[i].append(df2Arr[indexArr[i]][3+j])
gDimensionsList

#Converting Dimensions List to Pandas DataFrame
gDimensionsDF = pd.DataFrame(gDimensionsList)
gDimensionsDF.columns = ['gX','gY','gZ']
#gDimensionsDF = gDimensionsDF.rename(index = {0:indexArr[0], 1:indexArr[1], 2:indexArr[2]}) figure out how to do non-manually
print("indexes with issues (algorithm) in order: ", indexArr)
print("Their respective dimensional angles from the gyroscope are recorded below, in index numerical order: ")
gDimensionsDF

#[str(x) for x in indexArr]
#convert int list to str list





#PRE-SCALING - USING G_Y (COLUMN 5) TO TEST BECAUSE G_Y SHOWED THE MOST PATTERN IN THE TRAINING DATA (/Data Collection 7-13-21.xlsx)
#model.predict(df2[['Column5']])

#model.predict_proba(df2[['Column5']])

#df2_y = model.predict(df2[['Column6']])
#df2_y = df2.Column7

#df2_y

#model.score(df2[['Column5']],df2_y)